---
title: "Migration-path.Rmd"
author: "Sarah Supp"
date: "2/10/2020"
output: html_document
---

##Code for cedar waxwing project, modified from eBird migration project (Supp et al. 2015)
(c) 2020, Niu and Supp


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggmap)
library(maptools)
library(fields)
library(sp)
library(raster)
library(maps)
library(mapdata)
library(rgdal)
library(raster)
library(gamm4)
library(tidyverse)
#library(dplyr)
#library(SDMTools)#FIXME: package ‘SDMTools’ is not available (for R version 3.6.2)
#library(devtools)
#install_github('r-barnes/dggridR', vignette=TRUE)
#install_github("r-spatial/sf") #C compiler error on mac
library(dggridR)
#library(geojsonio)
library(RColorBrewer)
library(geosphere)
library(mgcv)
library(radiant.data)
```

If starting from scratch, input the three raw data files and 
```{r}
#load("data/Bombycilla_cedrorum.RData")
#load("data/effort.Rdata")
#load("data/locs.Rdata")

# #merge locations data on POLYFID so it includes the center of each hex cell (LONGITUDE.y, LATITUDE.y)
# dat_merged = merge(ebrd2.c, locs, by.x = "POLYFID", by.y = "POLYFID")
# 
# #now merge with the third data file for effort
# dat_effort = merge(dat_merged, eft.c, by.x = c("POLYFID", "YEAR", "DAY"), by.y = c("POLYFID","YEAR",  "DAY"))
# dat_effort$DAY <- as.numeric(dat_effort$DAY)
#save(dat_effort, file = "data/dat_effort.RData")
```

If you have already completed the initial steps and have saved out the effort file, start here instead, with loading it.
```{r}
load("data/dat_effort.RData")
```

[La Sorte et al. 2014](https://onlinelibrary.wiley.com/doi/full/10.1111/jbi.12328) defined western, central, and eastern flyways for migrating songbirds. These are general, but since our species include populations across the continent, and we are focused on *eastern and central* populations of eastern redcedar, we should exclude western occurrences (<103 longitude).
```{r}
dat_effort <- dat_effort %>%
  filter(lon >=-103)
```


## Weight mean locations 
Weight Bombycilla counts by eBirder effort counts for each cell
```{r} 
weighted_mean_locs <- dat_effort %>%
group_by(YEAR, DAY) %>%
  summarise(
            numcells = n(), 
            numobs = sum(count.x),
            wtmean_lon = weighted.mean(lon, count.x/count.y), 
            wtmean_lat = weighted.mean(lat, count.x/count.y), 
            wtsd_lon <- weighted.sd(lon, count.x/count.y),
            wtsd_lon <- weighted.sd(lat, count.x/count.y)
            )
```


Count number of records by year *for 2020 NSF report*
```{r}
#count total number of records across the years. (increasing strongly)
counts <- dat_effort %>%
  group_by(YEAR) %>%
  tally()

ggplot(counts, aes(YEAR, n)) + geom_bar(stat="identity") + 
  theme_bw() + ylab("Number of binned observations") + xlab("Year")

#checking how many unique grid cells logged an observation in each year (relatively flat)
nPOLYFID <- dat_effort %>%
  group_by(YEAR) %>%
  summarise(n=n_distinct(POLYFID))

ggplot(nPOLYFID, aes(YEAR, n)) + geom_bar(stat="identity") + 
  theme_bw() + ylab("Number of unique grid cells") + xlab("Year")

#checking how many days per year have at least 1 observation (ALL of them)
nDAYSofyear <- dat_effort %>%
  group_by(YEAR) %>%
  summarise(n=n_distinct(DAY))

ggplot(nDAYSofyear, aes(YEAR, n)) + geom_bar(stat="identity") + 
  theme_bw() + ylab("Number of unique days per year") + xlab("Year")
```


Initial plot of bird average locations for cedar waxwing species and latitude by day across years *for 2020 NSF report*
```{r}
# ggplot(weighted_mean_locs, aes(wtmean_lon, wtmean_lat)) +
#   geom_point(alpha=0.25) + geom_line(alpha=0.25) +
#   facet_wrap(~YEAR)

ggplot(weighted_mean_locs, aes(DAY, wtmean_lat, group=YEAR)) +
  geom_point(alpha=0.25) + geom_line(alpha=0.25) +
  facet_wrap(~YEAR)

ggplot(weighted_mean_locs, aes(as.numeric(DAY), wtmean_lat, group=YEAR)) +
  stat_smooth(aes(col=as.numeric(YEAR))) + ylab("Weighted mean latitude") +
  xlab("Day of the year") + 
  scale_x_continuous(breaks = seq(1, 366, by = 15))
```


This section generates the icosahedron cells and assigns the observations, weighted by total eBirder effort, for each cell in each day in each year, separately.
```{r}
dgg <- dgconstruct(project = "FULLER", aperture = 4, 
                   topology = "HEXAGON", res = 6)
dat_effort$cell <- dgGEO_to_SEQNUM(dgg, dat_effort$lon, 
                                   dat_effort$lat)$seqnum
dat_effort$cell_lat <- dgSEQNUM_to_GEO(dgg, dat_effort$cell)$lat_deg 
dat_effort$cell_lon <- dgSEQNUM_to_GEO(dgg, dat_effort$cell)$lon_deg 

dat_effort <- dat_effort %>%
  mutate(count_weighted = count.x/count.y)


#cellcenters   <- dgSEQNUM_to_GEO(dgg, dat_effort$cell)
cewa_counts <- dat_effort %>%
  group_by(cell) %>% 
  summarise(sum_weighted_count=sum(count_weighted),
            mean_weighted_count=mean(count_weighted),
            sum_count=sum(count.x))

ggplot(cewa_counts, aes(x=sum_weighted_count)) +
  geom_histogram(binwidth=10)

ggplot(cewa_counts, aes(x=mean_weighted_count)) +
  geom_histogram(binwidth=0.01)

ggplot(cewa_counts, aes(x=sum_count)) +
  geom_histogram(binwidth=100)
```


## Create a map of eBird effort (all years, all dates)
Plots the weighted observations of the species (Cewa) by icosahedron grid cells across Central and Eastern North America.
```{r}
#Get the grid cell boundaries for cells which had bird observations
grid <- dgcellstogrid(dgg, cewa_counts$cell, frame=TRUE, wrapcells=TRUE)

#Update the grid cells' properties to include the number of observations in each cell
grid <- merge(grid, cewa_counts, by.x="cell", by.y="cell")
#zoom to just eastern USA
grid <- grid %>%
  filter(long >= -103,
         lat >= 25)
#Get polygons for the spatial range and make a map of bird observations
countries <- map_data("usa") 

ggplot() + 
  #geom_polygon(data=countries, aes(x=long, y=lat, group=group), fill=NA, color="black")   +
  geom_polygon(data=grid, aes(x=long, y=lat, group=cell, fill=mean_weighted_count), alpha=0.4)    +
  geom_path   (data=grid, aes(x=long, y=lat, group=cell), alpha=0.4, color="white") +
#  geom_point  (aes(x=cellcenters$lon_deg, y=cellcenters$lat_deg), size=0.5) +
  scale_fill_gradient(low="gray90", high="black") + 
 theme_bw()
  #scale_fill_gradient2(low="blue", high="red", midpoint = 250)

```


## Create a map of Bombycilla counts (all years, all dates)

```{r}
#TODO: Make how you prefer, but feel free to plot the data as the actual locations of the birds 
#       (from the .csv files), or to use the .Rdata files to plot the polygon center, maybe with 
#       point sized or colored by magnitude of the count.
all_states <- map_data("state")
#states <- subset(all_states, region %in% c('ohio', 'michigan', 'kentucky', 'tennessee', 'indiana', 
#                                           'illinois', 'iowa', 'nebraska','south dakota', 'north dakota',
#                                           'minnesota', 'wisconsin', 'missouri', 'kansas'))
uw_cewa_counts <- dat_effort %>%
  group_by(cell) %>% 
  summarise(count_new_uw=sum(count.x))
uw_grid <- dgcellstogrid(dgg, uw_cewa_counts$cell, frame=TRUE, wrapcells=TRUE)

uw_grid <- merge(grid, uw_cewa_counts, by.x="cell", by.y="cell")

p <- ggplot() +
  geom_polygon( data=all_states, aes(x=long, y=lat, group = group), colour="black", fill="white" ) +
  geom_polygon(data=uw_grid,      aes(x=long, y=lat, group=cell, fill=count_new_uw), alpha=0.4)    +
  
  geom_path   (data=uw_grid,      aes(x=long, y=lat, group=cell), alpha=0.4, color="white") +
#  geom_point  (aes(x=cellcenters$lon_deg, y=cellcenters$lat_deg), size=0.5) +
  scale_fill_gradient2(low="blue", high="red",midpoint = 10000 ) +
  labs(title="Cedar Waxwing locations") + 
  theme_bw() + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
p
```


## Estimate migration pathway for Bombycilla each year separately - DONE (ABOVE)
```{r}
#TODO: use or modify code from "migration-fxns.r" file, AlternateMeanLocs
#       that method used a loop to go through each year separately, 
#       but could probably be written using dplyr or apply (purr??) to simplify and optimize
#       I'm sure there's a more elegant way to do it. Basically, we need to calculate a weighted mean
#       for longitue and latitude, separately. We could use the wt.mean function (pkg=SDMTools), and #       the weight would be the cedarwaxwing count/total ebirder count from each row in the merged 
#       Bombycilla-effort dataset. I wrote the referenced code before I became a tidyverse user. 
#       for example: wt.mean(mergedata$Longitude, mergedata$BombycillaCount/mergedata$ebirdCount)



```



## Use GAM model to predict daily location along a smoothing line, from the weighted mean locations
```{r}
#TODO: Modify and update code from "migration-fxns.r" file, for EstimateDailyLocs. 
#       Takes the new mean locations as input and outputs the smoothed migration path day by day.
#       Can also see implemented in hb-migration.r: preds = EstimateDailyLocs(meanlocs)
weighted_mean_locs$DAY <- as.numeric(weighted_mean_locs$DAY)
weighted_mean_locs$YEAR <- as.numeric(weighted_mean_locs$YEAR)

EstimateDailyLocs = function(dat) {
  #input a dataframe with the mean daily locations for the year, and uses a GAM smoothing function
  # to estimate daily occurrence lat and long separately. Binds the fitted lat and long values together,
  # with standard errors. Returns a dataframe.
      #check choice of k and gamma in the GAM function - same as FAL 2013
  #find the best fit line for the data, for longitude and latitude separately
  lon_gam = gam(wtmean_lon ~ s(DAY, k=20), data = weighted_mean_locs, gamma = 1.5) # TODO: consider upping gamma? and changing basis? (adaptive spline or penalized spline?)
  lat_gam = gam(wtmean_lat ~ s(DAY, k=20), data = dat, gamma = 1.5)
  
  #predict values along the smoothing line
  xpred = data.frame(DAY=sort(unique(dat$DAY)))
  lonpred = predict(lon_gam, newdata = xpred, type="response", se.fit=T)
  latpred = predict(lat_gam, newdata = xpred, type="response", se.fit=T)
  
  #bring the data back together
  preds =  data.frame(DAY = xpred$DAY, lon = lonpred$fit, 
                      lat = latpred$fit, lon_se = lonpred$se.fit, lat_se = latpred$se.fit)
  
  return(preds)
}

#FIXME: How to elegantly apply this to each year separately? Or should I do it continuously for the whole dataset, in which case I need to create a date variable?
dailylocs <- EstimateDailyLocs(weighted_mean_locs)

ggplot(dailylocs, aes(DAY, lat)) + geom_line(size=1) + 
  geom_vline(xintercept=c(101, 209, 362), col="gray30") + #FIXME: Update xintercepts
  xlab("Day of Year") + ylab("weighted mean latitude") +
  theme_bw()

```


```{r}
x <- c(2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019)
count <- 2008
df <- data.frame()
EstimateDailyLocs_year = function(dat) {
  for (i in x) {
   sub_weighted_mean_locs <- 
     dat %>%
     filter(YEAR == i)
   
   lon_gam = gam(wtmean_lon ~ s(DAY, k=20), data = sub_weighted_mean_locs, gamma = 1.5)
   lat_gam = gam(wtmean_lat ~ s(DAY, k=20), data = sub_weighted_mean_locs, gamma = 1.5)
   xpred = data.frame(DAY=sort(unique(sub_weighted_mean_locs$DAY)))
   lonpred = predict(lon_gam, newdata = xpred, type="response", se.fit=T)
   latpred = predict(lat_gam, newdata = xpred, type="response", se.fit=T)
   preds =  data.frame(DAY = xpred$DAY, lon = lonpred$fit, 
                        lat = latpred$fit, lon_se = lonpred$se.fit, lat_se = latpred$se.fit, YEAR = i)
  df <- data.frame(append(df, preds))
 
  }
  return(df)
}
dailylocs_year <- EstimateDailyLocs_year(weighted_mean_locs)
#FIXME
```



# estimate 3 migration dates, beginning of spring, peak latitude (summer), end of fall migration
```{r}
# TODO: from old function Est3MigrationDates in migration-fxns

Est3MigrationDates = function(dat){
  #takes in predicted centroids for migration path, and estimates the beginning of spring migration,
  # the end of fall migration, and the date where the species reaches maximum latitude.
  
  #GAM model on predicted latitude of centroids by julian date
  gam1 = gam(wtmean_lat ~ s(DAY, k = 40), data = dat, gamma = 1.5) 
  xpred = data.frame(DAY = c(1:max(dat$DAY)))
  dpred = predict(gam1, newdata=xpred, type="response", se.fit=TRUE)
  
  ## cutoff based on 2 SE for spring and fall combined, following La Sorte et al. 2013 methods
  # Spring migration should be between 11 Jan and 9 July
  # Fall migration should be between 8 August and 21 Dec
  spring_threshold = min(dpred$se.fit[c(1:120)]*2.56 + dpred$fit[c(1:120)])
  fall_threshold = min(dpred$se.fit[c(280:365)]*2.56 + dpred$fit[c(280:365)])
  spring_index = 11:190
  fall_index = 220:355
  spring_max = spring_index[which.max(dpred$fit[spring_index])]
  fall_max = fall_index[which.max(dpred$fit[fall_index])]
  
  #identify beginning of spring migration
  tst = 1000
  spring_index2 = spring_max
  while(tst > spring_threshold){
    tst = dpred$fit[spring_index2]
    if(spring_index2 == 1) break
    spring_index2 = spring_index2 - 1
  }
  spring_begin = spring_index2 + 1
  
  #identify end of fall migration
  tst <- 1000
  fall_index2 = fall_max
  while(tst > fall_threshold){
    tst = dpred$fit[fall_index2]
    if(fall_index2==365) break
    fall_index2 <- fall_index2 + 1
  }
  fall_end <- fall_index2 - 1
  
  max_lat =   xpred$DAY[which.max(dpred$fit[xpred$DAY])]
  
  dates = c(spring_begin, max_lat, fall_end)
  return(dates)
}

dates <- Est3MigrationDates(weighted_mean_locs)
```

Find the distances traveled between the mean locations 
#FIXME: I should be using the predicted locations (daily locs) here, not the raw weighted ones
```{r}
#order everything by year and day of year
dailylocs_2008<- dailylocs_year %>%
  group_by(YEAR)%>%
  arrange(YEAR,DAY)

#FIXME: Check values. Some of these seem WAY too high
#calculate sequential distances, adding NA for the first record
distances <- append(NA, distVincentyEllipsoid(as.matrix(dailylocs_2008[,c(5,6)])))/1000

# add column to original dataset
dailylocs_2008$distance <- distances


#  filter(DAY >= migration_dates$spring_begin & migration_dates <= migration_dates$autumn_end)

#FIXME: 
ggplot(dailylocs_2008, aes(as.numeric(DAY), distance, group=YEAR)) + geom_line() + 
  theme_bw() + xlab("Julian Day") + ylab("Distance Traveled (km)") + 
  theme(text = element_text(size=20)) + 
  facet_wrap(~YEAR)#+  
  #geom_vline(xintercept = median(migr_dates), col = "indianred", linetype = "dashed")
```