---
title: "Migration-path.Rmd"
author: "Sarah Supp"
date: "2/10/2020"
output: html_document
---

# INTRODUCTION

## Code for cedar waxwing project, modified from eBird migration project (Supp et al. 2015)
(c) 2020-2023, Niu, Lee, Wisnefski, and Supp (PI)
supps@denison.edu
Denison University
Code is under development, part of NSF Multi-Institution Collaborative Award (2019-2025)
modified from previous code developed for Supp et al. 2015 hummingbird paper (Ecosphere)

Birds evaluated include: 
* Cedar Waxwing (CEWA) _Bombycilla cedrorum_
* Robin (ROBI) _Turdus migratorius_
* Wood Thrush (WOTH) _Hylocichla mustelina_
* Yellow-rumped Warbler (YEWA) _setophaga coronata_
* Blue Jay (BLJA) _Cyanocitta cristata_
* European Starling (EUST) _Sturnus vulgaris_
* Eastern Bluebird (EABL) _Sialia sialis_
* Northern Mockingbird (NOMO) _Mimus polyglottos_
* Downy Woodpecker (DOWO) _Dryobates pubescens_
* Eastern Meadowlark (EAME) _Sturnella magna_
* White-breasted Nuthatch (WHNU) _Sitta carolinensis_
* Purple Finch (PUFI) _Haemorhous purpureus_
* Northern Cardinal (NOCA) _Cardinalis cardinalis_
* Dark-eyed Junco (DAJU) _Junco hyemalis_
* American Crow (AMCR) _Corvus brachyrhynchos_


##FIXME: check which of these libraries is  used, and remove ones that are not needed
```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(here)
library(broom)
#library(devtools)
#devtools::install_github('r-barnes/dggridR', vignette=TRUE, force = TRUE)
library(dggridR)
library(features)
library(fields) #FIXME: Test if this is needed or already loaded in background with sf or sp
library(gamm4) 
library(geosphere)
#devtools::install_github("dkahle/ggmap")
library(ggmap)
library(ggpubr)
library(lubridate)
library(maps)
#library(mapdata) #FIXME: remove if not needed
library(mgcv)
library(maptools)
library(purrr)
library(RColorBrewer)
#devtools::install_github("r-spatial/sf") #C compiler error on mac
library(sf)
library(viridis)
#library(sjPlot)
#library(sjmisc)
#library(sjlabelled)
```

For this code chunk, you need to already have processed the raw eBird data files (process-raw-eBird-data.Rmd) and generated the daily centroids using the nvector method and weighted means (daily-nvector-centroids.Rmd). The second step should have generated these files in the intermediate data folder: dat_effort_filtered.rds, df_nvector.rds, weighted_mean_locs.rds. If you have not yet run these steps or generated the .rds output files, please go back and run those two files in that order first. 

**Note:** dat_effort_filtered.rds and weighted_mean_locs.rds have already been **filtered to the eastern flyway**. [La Sorte et al. 2014](https://onlinelibrary.wiley.com/doi/full/10.1111/jbi.12328) defined western, central, and eastern flyways for migrating songbirds. We use this filter because our species include populations across the continent, and we are focused on eastern and midwestern populations of eastern redcedar. Thus, our processed data excludes western occurrences (<-103 longitude). *If you want to include occurrences from broader locations, will need to use the individual species files generated by the process-eBird-data.Rmd (pre-filtering).*


# Load the processed data 
#### Includes files for: merged species, nvector locations, and the weighted mean daily centroids
These files are generated by the code "daily-nvector-centroid.Rmd".

#FIXME: the files loaded below are now named 2024 (updated in Nov 2024). After removing the old 2023 files and committing the change, delete this note. #FIXME: I removed all the year references for simpler naming...

Loads the processed data
```{r}
# #Loading RDS files for filtered effort, nvector values, and centroids (weighted mean locations)
dat_effort <- readRDS(here("data/2-intermediate_eBird_data/dat_effort_filtered.rds"))
df <- readRDS(here("data/2-intermediate_eBird_data/df_nvector.rds"))
weighted_mean_locs <- readRDS(here("data/2-intermediate_eBird_data/weighted_mean_locs.rds"))
```

# Data summaries for manuscript and annual reporting
Count number of records by year *for NSF report*
```{r}
#count total number of records across the years. (increasing strongly)
counts <- df %>%
  group_by(species, year) %>%
  tally()

num_bins <- ggplot(counts, aes(year, n)) + geom_bar(stat="identity") + 
  theme_bw() + ylab("Number of binned observations") + xlab("Year") +
  theme(axis.text.x = element_text(angle = 90)) + 
  facet_wrap(~species, ncol=1)

#checking how many unique grid cells logged an observation in each year (relatively flat)
nPOLYFID <- df %>%
  group_by(species, year) %>%
  summarise(n=n_distinct(POLYFID))

num_gridcells <- ggplot(nPOLYFID, aes(year, n)) + geom_bar(stat="identity") + 
  theme_bw() + ylab("Number of unique grid cells") + xlab("Year") +
  theme(axis.text.x = element_text(angle = 90)) + 
  facet_wrap(~species, ncol=1)

#checking how many days per year have at least 1 observation (ALL of them)
nDAYSofyear <- df %>%
  group_by(species, year) %>%
  summarise(n=n_distinct(day))

num_days <- ggplot(nDAYSofyear, aes(year, n)) + geom_bar(stat="identity") + 
  theme_bw() + ylab("Number of unique days per year") + xlab("Year") +
  theme(axis.text.x = element_text(angle = 90)) + 
  facet_wrap(~species, ncol=1)

ggarrange(num_bins, num_gridcells, num_days,
          labels=c("A", "B", "C"),
          ncol=3, nrow=1)

ggsave(filename = here("figs/15spp_counts.png"), height = 11, width=8)
```


Initial plot of bird average locations for all species and latitude by day across years *for NSF report*
```{r}
wtlon_by_day <- ggplot(weighted_mean_locs, aes(day, weighted_lon, group=year)) +
  geom_point(alpha=0.25, aes(col=winter)) + geom_line(alpha=0.25) +
  facet_wrap(~year) + 
  theme_bw()

wtlat_by_day <- ggplot(weighted_mean_locs, aes(as.numeric(day), weighted_lat, group=year)) +
  stat_smooth(aes(col=as.numeric(year))) + ylab("Weighted mean latitude") +
  xlab("Day of the year") + 
  scale_x_continuous(breaks = seq(1, 366, by = 60)) +
  facet_wrap(~species) + 
  theme_bw()

ggsave(wtlat_by_day, filename = here("figs/15spp_wtmean_smooth.png"), height = 11, width=8)
```


## Prepares the hexagonal grid cells for later plotting, and summarizes the frequencies by cell
* freq = number of checklists / total effort, per cell
* sum_weighted_count = the sum of all the frequencies within a cell. A proxy for comparing how often target species occur in a given cell.
* mean_weighted_count = the average frequency for a cell. A proxy for how often target species occur in a given cell.

**Note:** the lines using the `dggridr` functions take a few minutes to run.
```{r}
#using the data filtered for eastern flyway (df); and cell centers calculated
dgg <- dgconstruct(project = "FULLER", aperture = 4, topology = "HEXAGON", res = 6)
df$cell <- dgGEO_to_SEQNUM(dgg, df$x, df$y)$seqnum
df$cell_lat <- dgSEQNUM_to_GEO(dgg, df$cell)$lat_deg 
df$cell_lon <- dgSEQNUM_to_GEO(dgg, df$cell)$lon_deg 

#cellcenters   <- dgSEQNUM_to_GEO(dgg, dat_effort$cell)
spp_counts <- df %>%
  group_by(species, cell) %>% 
  summarise(sum_weighted_count=sum(freq),
            mean_weighted_count=mean(freq),
            sum_count=sum(count)) %>%
  ungroup()

ggplot(spp_counts, aes(x=mean_weighted_count)) +
  geom_histogram(binwidth=0.01) + 
  facet_wrap(~species) + 
  theme_bw()

```


## Create a map of eBird effort (all years, all dates) across Eastern North America
This uses the data that has already been filtered to only consider occurrences >=-103 longitude.

For help with dggridR functions, see: https://github.com/r-barnes/dggridR/blob/master/vignettes/dggridR.Rmd. 

```{r}
#Get the grid cell boundaries for cells which had bird observations
grid <- dggridR::dgcellstogrid(dgg, spp_counts$cell) 


#Update the grid cells' properties to include the number of observations in each cell
grid <- merge(grid, spp_counts, by.x="seqnum", by.y="cell")

# #Make adjustments so the output is more visually interesting
#  grid$count    <- log(grid$sum_count)
#  cutoff        <- quantile(grid$count,0.9)
#  grid          <- grid %>% mutate(count=ifelse(count>cutoff,cutoff,count))

#Get polygons for the spatial range and make a map of bird observations
world_map <- map_data("world")
north_america <- world_map %>%
  filter(region %in% c("USA", "Canada", "Mexico", "Guatemala", "Belize", 
                       "El Salvador", "Honduras", "Nicaragua", "Costa Rica", 
                       "Panama"))

# plot the number of checklists submitted (summed) per grid cell (2008-2023)
ggplot() + 
  geom_sf(data = grid, aes(fill = sum_count), color = alpha("white", 0.4 )) +
  geom_polygon(data=north_america, aes(x=long, y=lat, group=group), fill=NA, color="black")   +
  scale_fill_gradient(low="grey90", high="black", na.value="white") +
  #scale_fill_gradient(low="red", high="yellow") +
  coord_sf(xlim = c(-103, -60), ylim = c(10, 65)) + #set limits without distorting boundaries
  labs(title = "Number of checklists submitted by grid cell, 2008-2024") +
  theme_minimal() + 
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank()) +
  facet_wrap(~species, ncol=5)

ggsave(filename = "figs/15spp_sum_checklist_grids.png", height = 11, width=8)

```

# Estimate migration pathways using Generalized Additive Model, population-level migration speed, and migration dates

## Estimate migration pathway for 15 species each year separately using GAMs
Use GAM model to predict daily location along a smoothing line, from the weighted mean locations. Daily location should be calculated for each year separately.

In the GAM, we can use the weighted mean locations (latitude and longitude) that we have already calculated above. These become the inputs to the gam model, which finds the predicted (smooth) migration path for each day. The predicted (fitted) values become the migration path for the species, which we will then use to estimate start of spring, peak latitude (breeding), and end of autumn migration. Between end Autumn migration and begin of Spring migration, is the expected time that most individual birds are on their wintering grounds and not actively migrating. 


## Creates a dataframe with the daily centroid, estimated from a smoothed GAM fit
**Note:** lat and lon in the resulting dataframe represent the predicted lat and lon from the smoothed line

This code chunk stores a function to use a GAM model to estimate smoothed centroids that represent the migration path. It uses the weighted mean latitude and longitude as inputs and returns new daily centroids based on the predicted model fits, along with lower and upper confidence intervals (LCI, UCI).

In this function, we use parameters as follows: 
* k = 20
* gamma = 1.5

```{r}
Estimatedailylocs = function(dat) {

  years <- unique(dat$year)
  spp <- unique(dat$species)
  
  #initialize empty dataframe
  df_dailylocs <- data.frame(species=character(), day=integer(), year=integer(), 
                             month=integer(), winter=character(), lon=numeric(), 
                             lat=numeric(), lon_se=numeric(), lat_se=numeric(), 
                             lon_LCI=numeric(), lon_UCI=numeric(),
                             lat_LCI=numeric(), lat_UCI=numeric()) 

  for (s in spp){
    for (i in years) {
      sub_weighted_mean_locs <- dat %>%
        filter(year == i & species == s)

      lon_gam = gam(weighted_lon ~ s(day, k=20), data = sub_weighted_mean_locs, gamma = 1.5)
      lat_gam = gam(weighted_lat ~ s(day, k=20), data = sub_weighted_mean_locs, gamma = 1.5)
      xpred = data.frame(day=sort(unique(sub_weighted_mean_locs$day)))
      lonpred = predict(lon_gam, newdata = xpred, type="response", se.fit=T)
      latpred = predict(lat_gam, newdata = xpred, type="response", se.fit=T)
      lon_lowerCI = lonpred$fit - 1.96 * lonpred$se.fit  # Lower bound of 95% CI Longitude centroid
      lon_upperCI = lonpred$fit + 1.96 * lonpred$se.fit  # Upper bound of 95% CI Longitude centroid
      lat_lowerCI = latpred$fit - 1.96 * latpred$se.fit  # Lower bound of 95% CI Latitude centroid
      lat_upperCI = latpred$fit + 1.96 * latpred$se.fit  # Upper bound of 95% CI Latitude centroid

      preds =  data.frame(species = s, day = xpred$day, year = i,
                          month = sub_weighted_mean_locs$month, winter = sub_weighted_mean_locs$winter,
                          lon = lonpred$fit, lat = latpred$fit, lon_se = lonpred$se.fit, 
                          lat_se = latpred$se.fit, lon_LCI = lon_lowerCI, lon_UCI = lon_upperCI,
                          lat_LCI = lat_lowerCI, lat_UCI = lat_upperCI)
      df_dailylocs <- data.frame(bind_rows(df_dailylocs, preds))
    }
  }
  return(df_dailylocs)
}
```

Run the GAM function on the weighted mean dataframe for all species.
```{r}
#get daily centroid locations for all species in all years
dailylocs <- Estimatedailylocs(weighted_mean_locs)

#filter to keep only the migratory species (9 species)
mig_spp_dailylocs <- dailylocs %>% 
  filter (species %in% c("Bombycilla_cedrorum", "Haemorhous_purpureus", 
                         "Hylocichla_mustelina", "Junco_hyemalis", 
                         "Setophaga_coronata", "Turdus_migratorius", 
                         "Sialia_sialis", "Sturnella_magna", 
                         "Sturnus_vulgaris"))
```

Plot results from the GAM model
```{r}
ggplot(mig_spp_dailylocs, aes(x=day, y=lat, group=year)) + 
  geom_point(aes(col=as.factor(year)), size=0.10) + 
  scale_color_viridis(discrete=TRUE, option="magma") + 
  facet_wrap(~species, scales="free") +
  xlab("day of year") + ylab("centroid latitude") + 
  labs(col = "Year") +
  theme_bw()

ggsave(filename = here("figs/9spp_GAMlatitude.png"), height = 6, width=8)
```

Plot GAM model results showing the lat-lon path on a geographic map by species
```{r}

# plot the number of checklists submitted (summed) per grid cell (2008-2024)
ggplot() + 
  geom_polygon(data=north_america, aes(x=long, y=lat, group=group), fill=NA, color="black")   +
  coord_sf(xlim = c(-103, -60), ylim = c(15, 55)) + #set limits without distorting boundaries
  geom_point(data=mig_spp_dailylocs, aes(lon, lat, col=winter), size=0.1, alpha=0.1) +
  scale_color_viridis(discrete=TRUE) +
  labs(title = "GAM smoothed migration path, 2008-2024") +
  theme_minimal() + 
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank()) +
  theme(legend.position="bottom") +
  guides(color = guide_legend(override.aes = list(size = 3, alpha=1) ) ) +
  facet_wrap(~species, ncol=3)

ggsave(filename = here("figs/9spp_GAMmap.png"), height = 6, width=8)
```

Plot the results of the smoothed daily locations (centroids) for the migratory species by day of year
```{r}
ggplot(mig_spp_dailylocs, aes(day, lat, group=year)) + 
  geom_line(linewidth=0.1, aes(col=winter)) +
  scale_colour_manual(values = c("grey50", "blue")) +
  # Day 91 = April 1; Day 273 = Sep 30
  geom_vline(xintercept=c(91, 273), col="gray30") +
  xlab("Day of Year") + ylab("centroid latitude") +
  facet_wrap( ~species, ncol=3) + 
  theme_bw()

ggsave(filename = here("figs/9spp_GAMlatitude_winter.png"), height = 8, width=8)
```

Plot the results of the smoothed daily locations (centroids) for the migratory species on a map
```{r}
ggplot(mig_spp_dailylocs, aes(lon, lat, group=year)) +
  geom_point(aes(col=winter), alpha=0.25, size=0.1) +
  geom_polygon(data=north_america, aes(x=long, y=lat, group=group), fill=NA, color="black")   +
  coord_sf(xlim = c(-103, -60), ylim = c(10, 65)) + #set limits without distorting boundaries
  scale_colour_manual(values = c("grey50", "blue")) +
  labs(title = "Daily centroids, 2008-2022") +
  theme_minimal() + 
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank()) +
  theme(legend.position = "none") +
  facet_wrap(~species, ncol=3)

ggsave(filename = here("figs/9spp_GAMmap_winter.png"), height = 8, width=6)

```

For relevance to ERC, we have labeled the monthts October-March as "winter" (blue). This is the time of year that ERC is fruiting and where it is most important to be eaten and passed through a bird's gut to enhance germination. For each species, we will also need to determine the lat-long of interest, that corresponds to the necessary time of year and falls within the ERC geographic range extent. 


## Find the distances (kilometers) traveled between the mean locations. 
This calculation uses Great Circle (ellipsoid) distance on the estimated daily locations from the GAM model predictions for latitude and longitude. Because of the way the distVicentyEllipsoid function works on the values, the rows *must* all be in chronological order.
All rows must exist, so any days of the year where the species was not recorded in eBird, must be identified and added with NA values.
```{r}
#identify dates with no location and assign all values to NA
missdates <- mig_spp_dailylocs %>%
  group_by(species, year) %>%
  #technically this leaves out DAY 366 in 2008, 2012, 2016, and 2020, but I don't think that matters?
  dplyr::reframe(missing = setdiff(1:365, day)) %>% 
  mutate(day = missing, month=NA, winter=NA, lon=NA, lat=NA, lon_se=NA, lat_se=NA,
         lon_LCI=NA, lon_UCI=NA, lat_LCI=NA, lat_UCI=NA) %>%
  dplyr::select(species, day, year, month, lon, lat, lon_se, lat_se, lon_LCI, lon_UCI, lat_LCI, lat_UCI)

#append the missing/NA date values to the main dailylocs dataframe
mig_spp_dailylocs <- bind_rows(mig_spp_dailylocs, missdates)
```

## Centroid distance moved, as kilometers per day (km/day)
Calculate the km/day moved, as sequential distances each day to day within the year
```{r}
#calculate sequential distances in kilometers using geosphere::distVicentyEllipsoid
#   adds NA for the first record
calc_dist_km <- function(lon, lat) {
  m <- cbind(lon,lat)
  dist <- append(NA, distVincentyEllipsoid(m))/1000
  return(dist)
}

mig_spp_dailylocs <- mig_spp_dailylocs %>%
  #order chronologically by year and day
  arrange(species, year, day) %>% 
  group_by(species, year) %>%
  #calculate sequential distances, adds NA for the first record
  mutate(distance_km = calc_dist_km(lon, lat)) %>%
  #Remove Day 1 for all years; due to our method separating GAM by year, it will be a flawed value
  filter(day != 1)

# saving the migratory species distances traveled to file 
saveRDS(mig_spp_dailylocs, file = here("data/2-intermediate_eBird_data/mig_spp_dailylocs.rds"))
```

Plot the results of the distance calculation
```{r}
dist_by_day <- ggplot(mig_spp_dailylocs, aes(as.numeric(day), distance, group=year)) + 
  geom_line(aes(col=winter), linewidth=0.1) +
  scale_colour_manual(values = c("grey50", "blue")) +
  xlab("Julian Day") + ylab("Distance Traveled (km)") + 
  theme(text = element_text(size=12)) + 
  theme_bw() + 
  theme(legend.position = "none") +
  facet_wrap(~species, ncol=3)
  #geom_vline(xintercept = median(day), col = "indianred", linetype = "dashed")
  #geom_vline(xintercept = median(migr_dates), col = "indianred", linetype = "dashed")
dist_by_day

ggsave(dist_by_day, filename = here("figs/9spp_centroid_dist_km.png"), height = 5, width=8)
```

## Estimate the maximum migration speed during migration 
First, remove all values for Day = 1. Because each GAM was calculated separately by year, distance between Dec 31 and Jan 1 will not be valid. 
Use the median of the top 5 migration speeds for each year separately, as the estimated maximum migration speed (km/day) for the species. 
Report the annual estimates, and an overall summary of the values pooled across years (mean, sd, median, 1st and 3rd quantiles)
```{r}
# Estimate the maximum migration speed for each year (km/day)
# To reduce choosing an extreme value, take the top 5 speeds for each species in each year, and report the median value
 max_speed <- mig_spp_dailylocs %>%
   filter(day != 1) %>%
   group_by(species, year) %>%
   slice_max(order_by=distance, n = 5, with_ties = FALSE) %>%
   summarize(max_speed = median(distance)) %>%
   ungroup()
 
# save the result as an rds file and as a txt file
saveRDS(max_speed, here("data/3-results_data/max_speed.rds"))
write.table(max_speed, here(file = 'data/3-results_data/max_speed_table.txt'), col.names = TRUE,
              row.names = FALSE, sep = "\t")
```

Let's further summarize the max speed for each species across years, to check how much it varies
```{r}
# reports mean, median, and sd across 2008-2022 for each species
max_speed_summary <- max_speed %>%
  group_by(species) %>%
  summarise(
    mean = mean(max_speed),
    sd = sd(max_speed),
    median = median(max_speed),
    Q1 = quantile(max_speed, probs=0.25),
    Q3 = quantile(max_speed, probs=0.75))

# save the result as an rds file and as a txt file
saveRDS(max_speed_summary, here("data/3-results_data/max_speed_summary.rds"))
write.table(max_speed_summary, here(file = 'data/3-results_data/max_speed_summary_table.txt'), col.names = TRUE,
              row.names = FALSE, sep = "\t")
```

Plot the annual maximum migration speeds for each species, with a horizontal line showing the median of all the years for a species pooled together.
```{r}
# plot yearly maximum migration speeds for each species
max_mig_speed_plot <- ggplot(max_speed, aes(year, max_speed, group=species)) + 
  geom_hline(data = max_speed_summary, aes(yintercept = median), color = "indianred") +
  geom_point(data=max_speed) +
  xlab("Year") + ylab("Max Speed (km/day)") + 
  scale_x_continuous(breaks=seq(2008, 2024, 4)) +
  theme_bw() + 
  theme(text = element_text(size=10), 
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        legend.position="bottom") + 
  facet_wrap(~species)
max_mig_speed_plot

ggsave(max_mig_speed_plot, filename = here("figs/9spp_MedMaxMigrationSpeed.png"), height = 5, width=8)
```


# estimate 3 migration dates, beginning of spring, peak latitude (summer), end of fall migration
This will need some editing to work on each year separately. Ideally a resulting data frame with columns for year, begin_spring, peak_latitude, end_autumn

```{r}
# modified from old function Est3MigrationDates in migration-fxns.R
Est3MigrationDates = function(dat){
  #takes in predicted centroids for migration path, and estimates the beginning of spring migration,
  # the end of fall migration, and the date where the species reaches maximum latitude.
  dat <- dat %>% filter(day != 1)
  year <- c(2008:2024)
  species <- unique(dat$species)
  df_dates <- data.frame(species=character(), year=integer(), spring=numeric(), maxlat=numeric(), fall=numeric()) #initialize empty dataframe
  
  for (s in species) {
    for (y in year){
      #subset data tos pecies and year, remove rows with missing longitude
      dat_subset <- dat %>% filter(species == s, year == y, !is.na(lon))
    print(paste0("species: ", s, "; year: ", y))
    
    #GAM model on latitude by julian date (estimate centroids)
    gam1 = gam(lat ~ s(day, k = 40), data = dat, gamma = 1.5) #FIX ME: Why k=40  and not k=20?
    xpred = data.frame(day = c(1:max(dat$day)))
    dpred = predict(gam1, newdata=xpred, type="response", se.fit=TRUE)
    
    #NOTE: These dates are seeking Jan 1-May 31 for Spring migration begin
    #                 AND          Aug 1-Dec 30 for Fall migration end 
    spring_threshold = min(filter(dat_subset, day %in% c(2:120))$lat_se*2.56 + 
                             filter(dat_subset, day %in% c(2:120))$lat, na.rm=TRUE) # Jan 2 ~ April 30
    fall_threshold = min(filter(dat_subset, day %in% c(244:364))$lat_se*2.56 + 
                           filter(dat_subset, day %in% c(244:364))$lat, na.rm=TRUE) # Sep 1 ~ Dec 30
    
    # Note: After removing DAY=1, there are years with 364 days and with 365 days. 
    #   In effect, the calculation is ignoring the last day of leap years, 
    #   but this should not significantly influence the fall threshold.
    
    ## cutoff based on 2 SE for spring and fall combined, following La Sorte et al. 2013 methods
    # Spring migration should be between 11 Jan and 9 July
    # Fall migration should be between 8 August and 21 Dec
    
    spring_index = intersect(c(11:190), dat_subset$day) # between 11 Jan and 9 July 
    fall_index = intersect(c(220:355), dat_subset$day) # between 8 August and 21 Dec
    spring_max = (dat_subset %>% filter(day %in% spring_index) %>% slice_max(lat))$day
    fall_max =  (dat_subset %>% filter(day %in% fall_index) %>% slice_max(lat))$day
    
    #identify beginning of spring migration
    tst = 1000
    spring_index2 = spring_max
    while(tst > spring_threshold){
      if(nrow(filter(dat_subset, day==spring_index2))>0) {
        tst = filter(dat_subset, day %in% spring_index2)$lat
        if(spring_index2 == 1) break #see if we have to put 2 
        spring_index2 = spring_index2 - 1
      }
      else { spring_index2 = spring_index2 - 1 }
    }
    spring_begin = spring_index2 + 1
    
    #identify end of fall migration
    tst <- 1000
    fall_index2 = fall_max
    while(tst > fall_threshold){
     # print(paste0("tst= ", tst, " fall_index2= ", fall_index2))
      if(nrow(filter(dat_subset, day==fall_index2))>0) {
        tst = filter(dat_subset, day==fall_index2)$lat
        if(fall_index2 == 1) break
        fall_index2 = fall_index2 + 1
      }
      else { fall_index2 = fall_index2 + 1 }
    }
    fall_end <- fall_index2 - 1
    
    # find center of the season, max latitude (e.g. population no longer moving north; breeding)
    max_lat = dat_subset[dat_subset$lat == max(dat_subset$lat),]$day
    dates = data.frame(species = s, year = y, spring = spring_begin, maxlat = max_lat, fall = fall_end)
    df_dates <- data.frame(bind_rows(df_dates, dates))
    }
  }
return(df_dates)
}
```


Run the estimate dates function with the migratory species, removing the partial migrants (method won't work and results won't make sense if there's not a clear breeding season max latitude and clear northward and southward migration movements).
Save the results to an rds file and a text file for later use.
```{r}
#test function
Sys.time()
#remove partial migrants
dailylocs <- mig_spp_dailylocs %>% filter(!species %in% c("Sialia_sialis", "Sturnella_magna", "Sturnus_vulgaris"))
migration_dates <- Est3MigrationDates(dailylocs)
Sys.time()

# save result as an rds and text file
saveRDS(migration_dates, file=here("data/3-results_data/migration_dates.rds"))
write.table(migration_dates, here(file = 'data/3-results_data/migration_dates.txt'), col.names = TRUE,
              row.names = FALSE, sep = "\t")
```



Calculate the median migration date for each species, across all the years
```{r}
#Calculate median migration date for each species
median_migdates <- migration_dates %>%
  group_by(species) %>%
  summarise(begin_spring = median(spring),
            end_autumn = median(fall),
            )

write.table(median_migdates, here(file = 'data/3-results_data/median_migration_dates.txt'), col.names = TRUE,
              row.names = FALSE, sep = "\t")
```

Visualize the estimated dates for the 6 migratory species
```{r}
#set winter dates based on the ERC fruiting season of October-March
end_winter = 90 #March 31
begin_winter = 274 #October 1

spring <- ggscatter(data=migration_dates, x="year", y="spring", facet.by="species", add="reg.line") +
  stat_cor(label.y = 10, aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~"))) +
  stat_regline_equation(label.y = -10) + 
  geom_hline(yintercept = end_winter, linetype="dashed", col="cadetblue3") +
  theme(text = element_text(size=9), axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  scale_x_continuous(breaks=seq(2008, 2024, 6)) +
  xlab("Year") + ylab("spring migration begin date") +
  theme_bw()

autumn <- ggscatter(data=migration_dates, x="year", y="fall", facet.by="species", add="reg.line") +
  stat_cor(label.y = 300, aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~"))) +
  stat_regline_equation(label.y = 285) + 
  geom_hline(yintercept = begin_winter, linetype="dashed", col="cadetblue3") +
  theme(text = element_text(size=9), axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  scale_x_continuous(breaks=seq(2008, 2024, 6)) +
  xlab("Year") + ylab("autumn migration end date") + 
  theme_bw()# 

ggarrange(spring, autumn,
          ncol=1, nrow=2)

ggsave(filename = here("figs/6spp_migration_dates.png"), height = 10, width=7.5)
```

# Statistically compare migration paths, speeds, and dates across the time-series for each species

Look at linear trends for dates of the migratory species to see if there is a significant directional trend, or not.
```{r}
# Function to extract relevant statistics from linear regression object, using tidy models
extract_lm_stats <- function(model) {
  summary_model <- summary(model)
  
  tidy_model <- broom::tidy(model, conf.int=TRUE) %>% 
    filter(term == "year")
  
  tibble(r2 = summary_model$r.squared,
    estimate = tidy_model$estimate,
    conf_low = tidy_model$conf.low,
    conf_high = tidy_model$conf.high,
    pvalue = tidy_model$p.value)
}

# Process each species for spring and autumn, separately
date_results <- migration_dates %>%
  group_by(species) %>%
  nest() %>%
  mutate(
    spring_lm = purrr::map(data, ~lm(spring ~ year, data = .x)),
    fall_lm = purrr::map(data, ~lm(fall ~ year, data = .x)),
    spring_stats = purrr::map(spring_lm, extract_lm_stats),
    fall_stats = purrr::map(fall_lm, extract_lm_stats)
  ) %>%
  select(-spring_lm, -fall_lm, -data) %>%
 unnest(cols = c(spring_stats, fall_stats), names_sep = "_")

# View results
date_results

# view only significant results
date_results %>% filter(spring_stats_pvalue < 0.05 | fall_stats_pvalue < 0.05)

# write to results file
write.table(date_results, here(file = 'data/3-results_data/lm_migration_dates.txt'), col.names = TRUE,
              row.names = FALSE, sep = "\t")
```





#FIXME: BEGIN HERE NEXT !!!






Now we just want to look at bird occurrences during the winter months, and in the latitudes that ERC occur in: 
Can use the winter column to grab all data October-March and the latitudes ~ 26-47 --Note that these choices are somewhat arbitrary, just to get a quick look now. Will need to get finer grained info from D. Ward and lab later...
```{r}
ERCbirds <- spp7dailylocs %>%
  filter(lat - lat_se > 27 & lat + lat_se < 47 & winter=="winter")

ggplot() + 
  geom_polygon(data=state_prov, aes(x=long, y=lat, group = group), colour="grey50", fill="white") + 
  geom_point(data=ERCbirds, aes(lon, lat, col=species), size=.1) + 
  xlim(-102,-52) + 
  ylim(25,50) +
  theme_bw() + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()) + 
  facet_wrap(~month)

```

# look at the dat_effort file locations, not just the daily locs (which are summarized centroids only)
```{r}
 spp7 <- df %>% filter (species %in% c("Bombycilla_cedrorum", "Haemorhous_purpureus", "Hylocichla_mustelina", "Junco_hyemalis", "Setophaga_coronata", "Turdus_migratorius", "Sialia_sialis") )

winter_dat_effort <- spp7 %>%
  mutate(DAYm1 = day-1,
         origin = paste0(year, "-01-01"),
         date = as.Date(DAYm1, origin=origin),
         month = month(date)) %>%
  mutate(winter = ifelse(month %in% c(10, 11, 12, 1, 2, 3), "winter", "non-winter")) %>%
  arrange(species,date) %>%
  ungroup() %>%
  mutate(ID = row_number()) %>%
  dplyr::select(-DAYm1, -origin) %>%
  filter(winter=="winter") %>%
  filter(y > 27 & x < 47)


  ggplot() + 
  geom_polygon(data=state_prov, aes(x=long, y=lat, group = group), colour="grey50", fill="white") + 
  geom_point(data=winter_dat_effort, aes(x, y, col=species), alpha=.2, size=.1) + 
  xlim(-102,-52) + 
  theme_bw() + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()) + 
  facet_grid(species~month)
```


#FIXME: I think that the "community analysis" belongs in a new .Rmd file, since it is analyzing data at a different scale (community vs. population).
#--------------------------------------------------
#Start spatial analysis... 

Now, try to summarize the number of unique species in each POLYFID on each day in each year for the winter ERC season (can be counted as nrow())
```{r}
sppR <- winter_dat_effort %>%
  group_by(cell, cell_lat, cell_lon, year, month, day) %>%
  summarize(num_spp = n())

# sppR <- dat_effort %>%
#     mutate(DAYm1 = DAY-1,
#          origin = paste0(YEAR, "-01-01"),
#          DATE = as.Date(DAYm1, origin=origin), 
#          MONTH = month(DATE)) %>%
#   group_by(POLYFID, YEAR, MONTH, DAY) %>%
#   summarize(num_spp = n())

ggplot(sppR, aes(as.factor(num_spp), cell_lat)) + geom_boxplot() + 
  facet_wrap(~year)
ggplot(sppR, aes(as.factor(num_spp), cell_lon)) + geom_boxplot() + 
  facet_wrap(~year)

avg<- sppR %>%
  group_by(year, month) %>%
  summarize(mean = mean(num_spp), 
            median = median(num_spp))

avg2 <- sppR %>%
  group_by(year, month, day) %>%
  summarize(mean = mean(num_spp),
            median = median(num_spp))

ggplot(sppR, aes(day, num_spp)) + 
  geom_boxplot() + 
  facet_wrap(~month)

ggplot(avg, aes(year, mean)) + geom_point() + facet_wrap(~month)
mod2 <- lm(mean~as.numeric(year), data=avg)
summary(mod2)

ggplot(avg, aes(mean)) + geom_histogram(aes(fill=year)) + facet_wrap(~month)

ggplot(avg, aes(year, median)) + geom_point() + facet_wrap(~month)

ggplot(avg2, aes(day, mean)) + geom_point() + facet_grid(year~month, scale="free")


```

Calculate the number of species in a hex cell for each month (as opposed to day). Save as a table and then plot it on the grid cell map, using viridis color scale.
```{r}
sppR_mo <- sppR %>%
  group_by(cell, cell_lat, cell_lon, year, month) %>%
  summarise(Smed=median(num_spp), 
            Smax=max(num_spp),
            Smin=min(num_spp))

#Get the grid cell boundaries for cells which had bird observations
grid <- dgcellstogrid(dgg, sppR_mo$cell, frame=TRUE, wrapcells=TRUE)
#grid <- dgcellstogrid(dgg, sppR_mo$cell)

#Update the grid cells' properties to include the number of observations in each cell
grid <- merge(grid, sppR_mo, by.x="cell", by.y="cell")

#zoom to just eastern USA
grid <- grid %>%
  filter(long >= -103,
         lat >= 25)
#Get polygons for the spatial range and make a map of bird observations
countries <- map_data("usa") 

grid2019 <- grid %>% filter(YEAR ==20222)

#plot just 2019, median values for the month
ggplot() + 
  #geom_polygon(data=countries, aes(x=long, y=lat, group=group), fill=NA, color="black")   +
  geom_polygon(data=grid2019, aes(x=long, y=lat, group=cell, fill=Smed), alpha=1)    +
  geom_path   (data=grid2019, aes(x=long, y=lat, group=cell), alpha=0.4, color="white") +
#  geom_point  (aes(x=cellcenters$lon_deg, y=cellcenters$lat_deg), size=0.5) +
  #scale_fill_gradient(low="gray90", high="black") + 
  scale_fill_viridis() +
  #scale_fill_gradient2(low="blue", high="red", midpoint = 250) 
  theme_void() + 
  facet_wrap(~MONTH)

ggsave("figs/winter2019.png", bg="transparent", height=7, width=11)

```

Calculate the slopes of species richness change across years, within cells. Plot the results to see if there is a trend of higher species disperser load through time. Need to think and check with FAL for ideas to see if we need to account for overall effort better (currently using as pres-only data, without weighted checks)
```{r}
# look at the structure of sppR_mo

cells <- unique(sppR_mo$cell)
months <- c(10, 11, 12, 1, 2, 3)
df_sppR <- data.frame(cell=numeric(), month=integer(), n=integer(), slope=numeric(), pVal=numeric(), cell_lat=numeric(), cell_lon=numeric()) #initialize empty dataframe

for (c in cells){
  dat <- sppR_mo %>% filter(cell == c)
  for (m in months){
    dat2 <- dat %>% filter(month == m)
    if (nrow(dat2) >= 3) {
      mod <- lm(Smed~as.numeric(year), data=dat2)
      n = nrow(dat2)
      slope = coef(mod)[[2]]
      pVal = glance(mod)$p.value[[1]]
      cell_lat = dat2$cell_lat[1]
      cell_lon = dat2$cell_lon[1]
      
      df_sppR <- rbind(df_sppR, c(c, m, n, slope, pVal, cell_lat, cell_lon))
    }
  }
}
#remove the NA values
#FIXME: are we dropping all the rows that has NA values? does sig = pValue? 
  # previously had this filter: filter(!is.na(sig)); FIXME: delete if no longer need this note
na.omit(df_sppR )
  
# adding factor names and levels to month, ordered by winter season, not calendar year
df_sppR$monthname <- month(as.numeric(df_sppR$month), label=TRUE)
df_sppR$monthname <- factor(df_sppR$monthname, levels=c("Oct", "Nov", "Dec", "Jan", "Feb", "Mar"))

# add column for significance
df_sppR$sig <- ifelse(df_sppR$pVal < 0.05, "sig", "NS")
  
#ggplot histogram, layered by identity for sig and NS
ggplot(df_sppR, aes(slope)) + 
  geom_histogram(aes(fill=sig), position="identity", alpha=0.5) +
  scale_fill_manual(values = c("gray", "darkturquoise")) + 
  geom_vline(xintercept=0, linetype="dashed", col="gray50") +
  theme_bw()

# ggplot boxplot by month for all significant slopes, commented code shows month comparisons, not currently included in figure
ggplot(df_sppR %>% filter(sig=="sig"), aes(monthname, slope)) + 
  geom_boxplot(fill="black", col="black", notch=TRUE) +
  geom_jitter(col="cyan3", alpha=0.5) +
  geom_hline(yintercept=0, linetype="dashed", col="black") +
  xlab("") +
  ylab("slope") +
#  stat_compare_means(method="wilcox.test", comparisons = list(c("Oct", "Nov"), c("Oct", "Jan"), c("Oct", "Feb"))) +
#  stat_compare_means(label = "p.signif", method = "t.test", ref.group = 1, hide.ns=TRUE) +
    theme(
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent",colour = NA),
        plot.background = element_rect(fill = "transparent",colour = NA),
        axis.text.y = element_text(colour="black", size=14),
        axis.title.y = element_text(colour="black", size=14)
        ) 
  #add significance, only difs were oct-nov, oct-jan, oct-feb
  # add text labels for mean slopes?

# Figure for ESA 2021 poster
#ggsave("figs/Smed_slopes_month.png", bg="transparent", height=3, width=11)

#average effect size, mean of the slopes
df_sppR %>% 
  filter(sig=="sig") %>%
#  group_by(monthname) %>%
  summarize(meanslope = mean(slope),
            medianslope = median(slope))

#plot by latitude? any signal here?
ggplot(df_sppR %>% filter(sig=="sig"), aes(cell_lat, slope)) + 
  geom_point(alpha=0.10) + 
  geom_hline(yintercept=0, linetype="dashed") +
  geom_smooth(method="lm") + 
  facet_wrap(~monthname)

# Figure for ESA 2021 poster
#ggsave("figs/sig_slopes_month_lat.png", bg="transparent", height=4, width=6)

# ggplot boxplot by month for all slopes, shaded jitter points by sig
ggplot(df_sppR, aes(monthname, slope)) + 
  geom_boxplot(fill="black", col="black", notch=TRUE) +
  geom_jitter(aes(col=sig), alpha=0.5) +
  scale_colour_manual(values=c("gray", "cyan3")) +
  geom_hline(yintercept=0, linetype="dashed", col="black") +
  xlab("") +
  ylab("slope") +
    theme(
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent",colour = NA),
        plot.background = element_rect(fill = "transparent",colour = NA),
        axis.text.y = element_text(colour="black", size=14),
        axis.title.y = element_text(colour="black", size=14)
        ) 

#some basic t.tests to show that all slopes (sig and sig+NS) were significantly different from Zero, and significantly positive (very few with lower richness through time) -- correlate to higher potential disperser load over the past decade -- could imply an increasing role for dispersers, but need to discuss with Frank what else we'd need to check to ensure that this isn't just due to increasing eBird effort (In retrospect I may not have yet controlled well for this, or need to use the weighted measures instead of presence only directly?)

```



Let's plot the map using the significant slopes, and all others shaded in grey
```{r}
#Get the grid cell boundaries for cells which had bird observations
grid <- dgcellstogrid(dgg, df$cell, frame=TRUE, wrapcells=TRUE)

#Update the grid cells' properties to include the number of observations in each cell
grid <- merge(grid, df, by.x="cell", by.y="cell")
#zoom to just eastern USA
grid <- grid %>%
  filter(long >= -103,
         lat >= 25)
#Get polygons for the spatial range and make a map of bird observations
countries <- map_data("usa") 

gridsig <- grid %>% filter(sig == "sig")
gridNS <- grid %>% filter(sig == "NS")

#plot significant values by viridis shades, nonsignificant values as grey
ggplot() + 
 # geom_polygon(data=countries, aes(x=long, y=lat, group=group), fill=NA, color="black")   +
  geom_polygon(data=gridsig, aes(x=long, y=lat, group=cell, fill=slope))    +
  geom_path   (data=gridsig, aes(x=long, y=lat, group=cell), alpha=0.4, color="white") +
#  geom_point  (aes(x=cellcenters$lon_deg, y=cellcenters$lat_deg), size=0.5) +
  #scale_fill_gradient(low="gray90", high="black") + 
  # scale_fill_viridis() +
  scale_fill_gradient2(low="navyblue", high="firebrick3", midpoint = 0) +
  geom_polygon(data=gridNS, aes(x=long, y=lat, group=cell), fill="grey") +
  #geom_path   (data=gridNS, aes(x=long, y=lat, group=cell), alpha=0.4, color="white") +
  theme_void() + 
  facet_wrap(~monthname, nrow=1) + 
  theme(legend.position = "left")

ggsave("figs/slope_Smed_change.png", bg="transparent", height=3.5, width=16)
```




#Little's range and FIA importance value species distribution map for Eastern red cedar
Try something with a shapefile
Downloaded this one for eastern red cedar from https://www.fs.fed.us/nrs/atlas/littlefia/species_table.html  
```{r}
#found some useful help here: https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/ 
#may also be useful to read thorugh here: https://geocompr.robinlovelace.net/reproj-geo-data.html 

# read shapefile
ERC <- readOGR(dsn = paste0(here(), "/data/shapefile/litt68av.shp"))
# convert to dataframe
ERC_df <- fortify(ERC)

# plot map using ggplot
ERCmap <- ggplot(ERC_df, aes(long,lat, group = group)) +
  geom_polygon(fill="darkolivegreen") +
  coord_equal() +
  labs(x = "Longitude (Degrees)",
       y = "Latitude (Degrees)",
      title = "ERC Range Map",
      subtitle = "D_Clarke_1866 Datum, Projection: Albers, Units: Degrees - Lat / Lon") + 
  theme_void()
ERCmap

# Figure for ESA 2021 poster
ggsave("ERC_range.png", ERCmap, bg="transparent")

#TODO reprojection of the range data is needed, or transformation of all other data including points to Albers, or it won't work.
# reproject data from Albers to WGS84 CRS
ERC_WGS84 = sf::st_transform(ERC, crs = "+proj=wgs84") #FIXME
ERC_WGS84 <- sp::spTransform(ERC,
                                CRS("+proj=wgs84")) #FIXME

# grab winter locations from the winter_dat_effort dataframe
# add a point to the map
mapLocations <- ERCmap +
                geom_point(data = winter_dat_effort,
                aes(x = lon, y = lat, group = NULL), colour = "orange",
                      size = .5)
mapLocations



--------------------------------
#FIXME: Error in ogrInfo(dsn = dsn, layer = layer, encoding = encoding, use_iconv = use_iconv,  : Cannot open data source
my_spdf <- readOGR( 
  dsn=paste0(here(), "/data/shapefile2/") , 
  layer="litt68av",
  verbose=FALSE
)

#explore the shapefile
summary(my_spdf)
length(my_spdf)
head(my_spdf@data)

# Basic plot of this shape file using Base R:
par(mar=c(0,0,0,0))
plot(my_spdf2, col="darkolivegreen", bg="grey80", lwd=0.25, border=0 )

# 'fortify' the data to get a dataframe format required by ggplot2
require(broom)
spdf_formytified <- tidy(my_spdf, region = "LITT68_ID")

# reproject data
spdf_WGS84 <- rgdal::spTransform(my_spdf,
                                crs(state_prov))

# get background map layers
state_prov <- rnaturalearth::ne_states(c("united states of america", "canada"))
us  <- map_data("usa")

# Plot it using ggplot2, just a shape, no context. Seems to be missing projection ?? Can't add points or background map.
ggplot() + 
  geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill="#69b3a2", color="white", alpha=0.25) +
  theme_void()

#TODO: Can't plot the shapefile onto the map because it isn't the right projection
#       sf should be abel to help this, maybe here? https://r-spatial.org/r/2018/10/25/ggplot2-sf-2.html 
ggplot(data = world) +
  geom_sf() + 
  geom_point(data=dat_effort, aes(x=lon, y=lat), size=0.2) + 
  coord_sf(xlim = c(-103, -48), ylim = c(24.5, 60), expand = FALSE) +
 #geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill="#69b3a2", color="white", alpha=0.25) +
  theme_void()
  
```



# OLD GAM method and plots with varying k and g values
###FIXME: decide whether to keep or delete.
Moving here to the end of the file for now, until the rest of the code is vetted and results updated.


#FIXME: probably can't use this method for this subset of species; don't have strong enough N-S migration
### Trying the gam in a way that allows us to vary k and g, and record the results. 
#FIXME: Edit method for calculating dates
If this works, may choose to delete the above function and to delete the Estimate migration dates function, as it could be a better method, that calculates both at the same time.
```{r}
#FIXME: Double check results versus the original version of this code
#   conduct sanity checks, and walk through code and results with collabs to check method.

# The output should contain the columns of year, 1st derivative of spring begin, 2nd derivative of spring end, 2nd derivative fall begin, ad 1st derivative of fall end from year 2008 to 2021. 

Sys.time()
# create values for unique years and species names
# Only incldue the migratory species 
species <- c("Bombycilla_cedrorum", "Haemorhous_purpureus", 
          "Hylocichla_mustelina", "Junco_hyemalis", 
          "Setophaga_coronata", "Turdus_migratorius", 
          "Sialia_sialis", "Sturnella_magna", 
          "Sturnus_vulgaris")
#need to take year from 2009 to 2021 so that it will include 2008 and 2022 as calculating the buffer year
years <- 2009:2023 

# initialize empty lists to store results
dataresult <- NULL 
lat_lon <- NULL 


for(s in species){
  #filtering dataset to species, remove day 366 so all years have 365 days (lose one day from leap years)
  dat <-weighted_mean_locs %>%
    filter(species == s, day != 366) 
  
  for (y in years) {
    #subset dataset to 3-year period
    buffer_years <- c(y-1, y, y+1)
    filter_yr <- dat %>% filter(year %in% buffer_years) 
    
    # Skip if buffer_years is empty or if there are fewer than 300 rows
    if (nrow(filter_yr) < 300) next

    # separate winter start and end from focal year
    # the day2 mutations create a sequence of values ranging -45 to 438 to keep the days in order  
    winter_start <- filter_yr %>% filter(year == buffer_years[1] & day > 319) %>% mutate(day2 = day - 365)
    focal_year <- filter_yr %>% filter(year == buffer_years[2]) %>% mutate(day2 = day)
    winter_end <- filter_yr %>% filter(year == buffer_years[3] & day < 74) %>% mutate(day2 = day + 365)
    
    # merge back together, sorted by day2 to retain the correct sequence to estimating migration
    merged_dat <- bind_rows(winter_start, focal_year, winter_end) %>% arrange(day2)

    # Define ranges to test a range of parameters for k and gamma
    k_vals <- seq(8, 20, 1)
    gamma_vals <- seq(0, 8, 1)
    
    # initialize empty lists to store results in
    dates <- vector("list", length(gamma_vals) * length(k_vals))
    predictions_lon <- vector("list", length(gamma_vals) * length(k_vals))
    predictions_lat <- vector("list", length(gamma_vals) * length(k_vals))
    index <- 1
    
    for (k in k_vals){
      for (g in gamma_vals){
        
         # LONGITUDE MODEL
         mdl_lon <- gam(weighted_lon ~ s(day2, k = k), data = merged_dat, gamma = g)
         x_data_lon <- data.frame(day2 = 1:365)
         prediction_lon <- predict(mdl_lon, newdata = x_data_lon, type = "response")
         predictions_lon[[index]] <- prediction_lon
        
         # LATITUDE MODEL
         mdl_lat <- gam(weighted_lat ~ s(day2, k = k), data = merged_dat, gamma = g)
         x_data_lat <- data.frame(day2 = 1:365)
         prediction_lat <- predict(mdl_lat, newdata = x_data_lat, type = "response")
         predictions_lat[[index]] <- prediction_lat
          
         # features package extracts the 1st and 2nd derivatives
         feature <- features(x_data_lat$day2, prediction_lat, 
                             smoother = "glkerns", control = list(npts = 365))
         first_derivative <- attributes(feature)$fits$d1
         second_derivative <- attributes(feature)$fits$d2
         
         # Compute dates for spring and autumn from the derivatives
         # FIXME: Double check with FAL; changed a bit from previous code, tested for the same values
         #    Are the min and max methods in the right place? Are the bracketed values OK? 
         #    Are the quantiles set appropriately?
         # numeric values in brackets chosen to contain the expected migration windows for the species
          spring_begin <- which.min(second_derivative[10:140]) + 9
          spring_middle = which.max(first_derivative[10:140]) + 9
          spring_end <- which.max(second_derivative[10:140]) + 9
          
          autumn_begin <- which.max(second_derivative[220:355]) + 219
          autumn_middle = which.min(first_derivative[220:355]) + 219
          autumn_end <- which.min(second_derivative[220:355]) + 219
          
          dates[[index]] <- data.frame(
            species = s,
            year = y,
            k = k,
            g = g,
            spring_begin = spring_begin,
            spring_middle = spring_middle,
            spring_end = spring_end,
            autumn_begin = autumn_begin,
            autumn_middle = autumn_middle,
            autumn_end = autumn_end
          )
          index <- index + 1
        
      }
    }
    # Combine and summarize results
    dates_df <- do.call(rbind, dates)
    avg_dates <- dates_df %>%
     summarise(
      ## quantile second derivative 
      ### method looks across all results to find the best line to match what you'd expect to see
      ### recommend using 0.1 and 0.9, found to work well on lots of species
      ### removes some of the extreme outliers
      spring_beginning = quantile(spring_begin, 0.1, na.rm = TRUE),
      spring_middle = mean(spring_middle, na.rm = TRUE),
      spring_end = quantile(spring_end, 0.9, na.rm = TRUE),
      autumn_beginning = quantile(autumn_begin, 0.1, na.rm = TRUE),
      autumn_middle = mean(autumn_middle, na.rm = TRUE),
      autumn_end = quantile(autumn_end, 0.9, na.rm = TRUE)
      ) %>%
      mutate(species = s, year = y)
    
    # collects the average dates into new dataframe  
    # collects results averaged across the different k and g parameter setting for lon and lat
    dataresult[[length(dataresult) + 1]] <- avg_dates
    avg_pred_lon <- rowMeans(do.call(cbind, predictions_lon), na.rm = TRUE)
    avg_pred_lat <- rowMeans(do.call(cbind, predictions_lat), na.rm = TRUE)
    lat_lon[[length(lat_lon) + 1]] <- data.frame(species = rep(s, 365), year = rep(y, 365), 
                                                   day = 1:365, lat = avg_pred_lat, lon = avg_pred_lon)
  }
}  

# Bind results into final data frames
final_mig_dates <- bind_rows(dataresult)
final_gam <- bind_rows(lat_lon)
  
list(dataresult = final_mig_dates, lat_lon = final_gam)
Sys.time()
```

Plot the results of the averaged daily locations (centroids) for the migratory species by day of year
#FIXME: these results indicate something weird going on with the date estimation from the varying k and g code above.
```{r}
ggplot(final_gam, aes(day, lat, group=year)) + 
  geom_line(linewidth=0.1) +
  #scale_colour_manual(values = c("grey50", "blue")) +
  # Day 91 = April 1; Day 273 = Sep 30
  geom_vline(xintercept=c(91, 273), col="gray30") +
  geom_vline(data=final_mig_dates, aes(xintercept=spring_beginning, group=year), col="blue", linewidth=0.5) +
  geom_vline(data=final_mig_dates, aes(xintercept=spring_end, group=year), col="blue", linewidth=0.5) +
  geom_vline(data=final_mig_dates, aes(xintercept=autumn_end, group=year), col="orange", linewidth=0.5) +
  geom_vline(data=final_mig_dates, aes(xintercept=autumn_beginning, group=year), col="orange", linewidth=0.5) +
  xlab("Day of Year") + ylab("centroid latitude") +
  facet_wrap(~species, scales = "free_y", ncol=3) + 
  theme_bw()
```

#FIXME: Just showing for one species for now.
Plot the results showing the lat-lon path by year
```{r}
ggplot() + 
  geom_polygon(data=north_america, aes(x=long, y=lat, group=group), fill=NA, color="black")   +
  coord_sf(xlim = c(-103, -60), ylim = c(25, 55)) + #set limits without distorting boundaries
  geom_point(data=final_gam, aes(lon, lat), size=0.1, col="indianred", alpha=0.1) +
  labs(title = "Bombycilla cedrorum, migration pathway 2008-2023") +
  theme_minimal() + 
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank()) +
  facet_wrap(~year, ncol=4)
```


#FIXME: Delete after confirming we don't need. 
I made this version in an attempt to optimize the function, but it's not getting the same/accurate results, and it fails if a day is missing or is NA
FIXME: SOMETHING IS WEIRD WITH THE FUNCTION BELOW. DELETE AND REMOVE? IT IS FASTER, BUT DOESN'T WORK ACCURATELY, GETS DIFFERENT DPRED AND ESTIMATED DATES RESULTS FROM ABOVE (WHICH I HAVE VETTED BEFORE)
FIXME: Some dates are missing. We filled these back in during the missdates function, but then they were removed again after the distance calculation. Perhaps doing these at the same time or in a different order can reduce the problem. And what to do if the while date is NA? As long as there is a row, then if the latitude is NA it won't matter, right? Move this function way up in the code, and then check that it works OK?
```{r}
# Optimized function to estimate migration dates
Est3MigrationDates_test <- function(dat) {
  # Remove entries for day 1 to clean data at the start
  dat <- dat %>% filter(day != 1)
  years <- 2008:2024
  species_list <- unique(dat$species)
  
  # Initialize an empty dataframe
  df_dates <- data.frame(species = character(), year = integer(), spring = numeric(), maxlat = numeric(), fall = numeric())
  
  for (s in species_list) {
    for (y in years) {
      # Filter data for the current species and year
      dat_subset2 <- dat %>% filter(year == y, species == s, !is.na(lon)) #FIXME: removing rows causes a problem.
      
      # Skip if there's no data for the species and year
      if (nrow(dat_subset2) == 0) next

      print(paste0("species: ", s, "; year: ", y))
      
      # GAM model on latitude by julian date
      gam_model2 <- gam(lat ~ s(day, k = 40), data = dat_subset2, gamma = 1.5)
      xpred2 <- data.frame(day = 1:max(dat_subset2$day))
      dpred2 <- predict(gam_model2, newdata = xpred2, type = "response", se.fit = TRUE)
      
      # Define thresholds for spring and fall migrations
      spring_threshold2 <- min(dpred2$fit[2:120] + 2.56 * dpred2$se.fit[2:120], na.rm = TRUE)
      fall_threshold2 <- min(dpred2$fit[244:364] + 2.56 * dpred2$se.fit[244:364], na.rm = TRUE)
      
      # Calculate indices for spring and fall ranges
      spring_index <- intersect(11:190, dat_subset$day)
      fall_index <- intersect(220:355, dat_subset$day)
      
      # Maximum latitude days within spring and fall indices
      spring_max <- dat_subset %>% filter(day %in% spring_index) %>% slice_max(lat) %>% pull(day)
      fall_max <- dat_subset %>% filter(day %in% fall_index) %>% slice_max(lat) %>% pull(day)
      
      # Determine the start of spring migration
      spring_begin <- spring_max
      #FIXME: What to do when this particular day's latitude is NA?
      while (spring_begin > 1 && dat_subset$lat[dat_subset$day == spring_begin] > spring_threshold) {
        spring_begin <- spring_begin - 1
      }
      spring_begin <- spring_begin + 1
      
      # Determine the end of fall migration
      fall_end <- fall_max
      while (fall_end < max(dat_subset$day) && dat_subset$lat[dat_subset$day == fall_end] > fall_threshold) {
        fall_end <- fall_end + 1
      }
      fall_end <- fall_end - 1
      
      # Maximum latitude day for the center of the season
      max_lat <- dat_subset %>% slice_max(lat) %>% pull(day)
      
      # Append calculated dates to df_dates
      df_dates <- bind_rows(df_dates, data.frame(species = s, year = y, spring = spring_begin, 
                                                 maxlat = max_lat, fall = fall_end))
    }
  }
  return(df_dates)
}

Sys.time()
MigrationDates_test <- Est3MigrationDates_test(mig_spp_dailylocs)
Sys.time()
```